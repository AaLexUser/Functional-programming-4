# Лабораторная работа №4

## Дисциплина

Функциональное программирование

## Выполнил

Лапин Алексей Александрович, P34102

## Цель работы

Получить навыки работы со специфичными для выбранной технологии/языка программирования приёмами.

## Требования

Retrieval-augmented generation (RAG) система на базе LLM в терминале.

| Параметр | Значение |
|---|---|
| Векторная бд | Pgvector |
| LLM | Ollama |
| Embedding модель | nomic-embed-text |

## Ход работы

### Структура проекта

```shell
├── README.md
├── src/
│   ├── common.clj
│   ├── core.clj
│   ├── populate-db.clj
│   └── query.clj
├── Dockerfile
├── docker-compose.yaml
├── build.clj
└── deps.edn
```

### Запуск приложения

#### Локальный запуск

1. Сборка uberjar:
```bash
clojure -T:build uber
```

2. Запуск приложения:
```bash
# Показать помощь
java -jar target/app.jar -h

# Добавить документы в базу данных
java -jar target/app.jar -p

# Запросить базу данных
java -jar target/app.jar -q "Цель курса"

# Сбросить базу данных
java -jar target/app.jar -r
```

#### Запуск через Docker

1. Запуск всех сервисов:
```bash
docker compose up --build
```

2. В отдельном терминале выполнить команды:
```bash
# Зайти в контейнер
make app-sh
# Добавить документы в базу данных
java -jar app.jar -p

# Запросить базу данных
make app-sh
java -jar app.jar -q "Цель курса"
```

### Реализация

#### Добавление документов в векторную бд
Для добавления документов в векторную бд необходимо положить новые документы в папку `data`.
Скрипт добавит все документы из папки в бд.

```clojure
(defn add-documents []
   (let [documents (load-documents)]
     (doseq [document documents]
       (let [ingestor (-> (EmbeddingStoreIngestor/builder)
                          (.documentSplitter (DocumentSplitters/recursive chunk-size chunk-overlap))
                          (.embeddingModel (get-embedding-model))
                          (.embeddingStore (get-embedding-store))
                          .build)]
         (.ingest ingestor document)
         (println "✨ Done populating database")))))
```

#### Запрос к RAG системе

RAG система использует следующий процесс:

1. Преобразует запрос в эмбеддинг
2. Находит релевантные фрагменты текста в векторной базе данных
3. Формирует промпт с найденным контекстом
4. Отправляет промпт в LLM для генерации ответа
5. Возвращает ответ и источники информации

```clojure
(defn query-rag [query-text]
  (let [retriever (create-content-retriever)
        query (Query/from (str/trim query-text))
        results (.retrieve retriever query)
        context (str/join "\n\n---\n\n" (map #(.text (.textSegment %)) results))
        prompt (-> (PromptTemplate/from prompt-template)
                   (.apply (java.util.HashMap. {"context" context
                                                "question" query-text})))
        model (get-chat-model)
        response (.generate model [(UserMessage/from (.text prompt))])
        sources (format-sources results)]
    (println (format "Response: %s\n%s" (.text (.content response)) (print-sources results)))
    {:response (.text (.content response))
     :sources sources}))
```

#### Ввод/вывод программы

1. Добавление документов в базу данных:
```bash
java -jar target/app.jar -p
```
Вывод:
```bash
✨ Done populating database
```

2. Запрос к базе данных:
```bash
java -jar target/app.jar -q "Цель курса"
```
Вывод:
```bash
Response: Цель лабораторного курса - получение практических навыков программирования в функциональной парадигме.
Sources:
----
ID: 0
Path: /Users/aleksejlapin/ITMO/FPLab4/data
Content: # Функциональное программирование. Лабораторный курс

Цель лабораторного курса: получение практических навыков программирования в функциональной парадигме.

Лабораторный курс сделан адаптируемым под интересы и нужды конкретного студента, поэтому доступны следующие степени свободы:
----
----
ID: 15
Path: /Users/aleksejlapin/ITMO/FPLab4/data
Content: 5. защита эссе, при этом возможны общие вопросы о невыбранных технологиях.
Примечания:
- при утверждении используемого языка программирования будет учитываться его популярность у ранее определившихся во избежание "курса по технологии Т";
- ограничения: не более 20% на технологию (25% на Erlang+Elixir);
- в случае блестящего обоснования -- ограничения могут быть нарушены;
- не любой язык программирования может быть утвержден;
----
----
ID: 48
Path: /Users/aleksejlapin/ITMO/FPLab4/data
Content: ```

Как видно из примера выше, окна для каждого метода двигаются по-разному. Для линейной окно начало сдвигаться уже при вводе третьей точки (т.к. для вычисления нужно всего две), в то время как для Лагранжа окно начало двигаться только когда была введена пятая точка (т.к. здесь для вычислений нужно больше точек).

Общие требования:
----
----
ID: 1
Path: /Users/aleksejlapin/ITMO/FPLab4/data
Content: Лабораторный курс сделан адаптируемым под интересы и нужды конкретного студента, поэтому доступны следующие степени свободы:

- Используемый язык программирования / технология согласуется студентом в рамках лабораторной работы №0.
- Лабораторная работа №4 претендует на решение задач, отражающих специфику выбранного языка. Учащимся предоставляется возможность предложить свою задачу в качестве варианта. При этом, данная задача может решаться как индивидуально, так и группой студентов.
----
----
ID: 2
Path: /Users/aleksejlapin/ITMO/FPLab4/data
Content: Учащимся предоставляется возможность предложить свою задачу в качестве варианта.

При этом, данная задача может решаться как индивидуально, так и группой студентов.

## Описание лабораторных работ

Все лабораторные работы, кроме четвертой, выполняются и защищаются индивидуально.
----

```

3. Сбросить базу данных:

```bash
java -jar target/app.jar -r
```

Вывод:

```bash
✨ Done resetting database
```

### Выводы

В ходе выполнения лабораторной работы были применены различные приёмы функционального программирования и современные практики разработки:

1. **Чистые функции и иммутабельность**: Основная логика приложения реализована с использованием чистых функций, что обеспечивает предсказуемость поведения и упрощает тестирование. Данные в приложении обрабатываются иммутабельно, что является одним из ключевых принципов функционального программирования.

2. **Композиция функций**: Активно использована композиция функций через операторы thread-first (->) и thread-last (->>) для создания цепочек преобразований данных, что делает код более читаемым и поддерживаемым.

3. **Разделение ответственности**: Код организован в отдельные пространства имён (core, query, populate-db, common), каждое из которых отвечает за свой аспект функциональности. Это улучшает модульность и переиспользуемость кода.

4. **Функции высшего порядка**: Использованы функции высшего порядка (map, doseq) для обработки коллекций данных, что является характерным для функционального стиля программирования.

5. **Контейнеризация**: Использование Docker и docker-compose для создания изолированной среды разработки и упрощения развёртывания приложения.

6. **Управление зависимостями**: Эффективное использование внешних библиотек через систему управления зависимостями Clojure, что позволило интегрировать современные инструменты для работы с LLM и векторными базами данных.

7. **Интеграция с Java**: В ходе выполнения лабораторной работы были получены практические навыки работы с Java библиотеками в Clojure, включая использование LangChain4j для работы с языковыми моделями и векторными базами данных.

8. **Сборка проекта**: Получен опыт работы с системой сборки Clojure проектов, включая создание исполняемых JAR файлов с помощью инструментов сборки.

Применение этих техник позволило создать надёжное, масштабируемое и легко поддерживаемое приложение.
